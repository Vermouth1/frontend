(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{430:function(v,e,t){"use strict";t.r(e);var _=t(26),a=Object(_.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[v._v("#")]),v._v(" 数据类型")]),v._v(" "),t("h2",{attrs:{id:"数值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数值"}},[v._v("#")]),v._v(" 数值")]),v._v(" "),t("h3",{attrs:{id:"parseint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parseint"}},[v._v("#")]),v._v(" parseInt")]),v._v(" "),t("p",[v._v("parseInt(string, radix) 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。("),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt",target:"_blank",rel:"noopener noreferrer"}},[v._v("MDN"),t("OutboundLink")],1),v._v(")")]),v._v(" "),t("p",[v._v("相关题目：")]),v._v(" "),t("ul",[t("li",[v._v("['1', '2', '3'].map(parseInt) what & why ?"),t("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4",target:"_blank",rel:"noopener noreferrer"}},[v._v("链接"),t("OutboundLink")],1)])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("ol",[t("li",[v._v("string 参数，"),t("strong",[v._v("如果参数不是一个字符串，则将其转换为字符串")]),v._v("。")]),v._v(" "),t("li",[v._v("返回 NAN 的情况\n"),t("ul",[t("li",[v._v("radix 小于 2 或大于 36")]),v._v(" "),t("li",[v._v("第一个非空格字符不能转换为数字。")])])])])]),v._v(" "),t("h2",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[v._v("#")]),v._v(" Set")]),v._v(" "),t("p",[v._v("新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。")]),v._v(" "),t("p",[v._v("Set 特点：")]),v._v(" "),t("ul",[t("li",[v._v("Set 本身是一种构造函数，用来生成 Set 数据结构。")]),v._v(" "),t("li",[v._v("Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。")])]),v._v(" "),t("p",[v._v("属性：")]),v._v(" "),t("ul",[t("li",[v._v("size：元素数量")])]),v._v(" "),t("p",[v._v("方法：")]),v._v(" "),t("ul",[t("li",[v._v("add(value)：新增。会判断两个值是否相等("),t("strong",[v._v("类似 === 判断，区别在 NaN 只能添加一次")]),v._v(")")]),v._v(" "),t("li",[v._v("delete(value)：存在即删除集合中value")]),v._v(" "),t("li",[v._v("has(value)：判断集合中是否存在 value")]),v._v(" "),t("li",[v._v("clear()：清空集合")])]),v._v(" "),t("p",[v._v("遍历：")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("ul",[t("li",[v._v("只有健值，没有健名，所以遍历的 key 和 value 一样")]),v._v(" "),t("li",[v._v("默认遍历器生成函数 values()")])])]),v._v(" "),t("ul",[t("li",[v._v("keys()")]),v._v(" "),t("li",[v._v("values()")]),v._v(" "),t("li",[v._v("entries()")])]),v._v(" "),t("h3",{attrs:{id:"weakset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weakset"}},[v._v("#")]),v._v(" WeakSet")]),v._v(" "),t("p",[v._v("和 Set 的区别")]),v._v(" "),t("ul",[t("li",[v._v("WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以")]),v._v(" "),t("li",[v._v("WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉，WeakSet中就无法取到这个对象。（垃圾回收采用"),t("strong",[v._v("引用计数")]),v._v("方法，WeakSet 里面的引用，都不计入垃圾回收机制，所以会被回收）")]),v._v(" "),t("li",[v._v("WeakSet 无法被遍历")]),v._v(" "),t("li",[v._v("没有 clear() 方法")])]),v._v(" "),t("p",[v._v("方法：")]),v._v(" "),t("ul",[t("li",[v._v("add() 同 Set，只能添加引用类型")]),v._v(" "),t("li",[v._v("has() 同 Set")]),v._v(" "),t("li",[v._v("delete() 同 Set")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("优势")]),v._v(" "),t("p",[v._v("WeakSet 比 Set 更适合（和执行）跟踪对象引用")])]),v._v(" "),t("h2",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[v._v("#")]),v._v(" Map")]),v._v(" "),t("p",[v._v("类似 Object，是键值对的集合。区别是可以键名可以是任意类型")]),v._v(" "),t("p",[v._v("键名如果是引用类型，只有是同一个引用才会看作同一个键。如果是基本类型的值，需要判断 === (NaN除外，看作一个键)")]),v._v(" "),t("p",[v._v("构造函数参数：具有 Iterator 接口，且每个成员都是一个双元素的数组的数据结构")]),v._v(" "),t("p",[v._v("属性：")]),v._v(" "),t("ul",[t("li",[v._v("size：返回 Map 中所包含的元素个数")])]),v._v(" "),t("p",[v._v("方法：")]),v._v(" "),t("ul",[t("li",[v._v("set(key, value) 向字典中添加新元素")]),v._v(" "),t("li",[v._v("get(key) 通过键查找特定的数值并返回")]),v._v(" "),t("li",[v._v("has(key)：判断字典中是否存在键key")]),v._v(" "),t("li",[v._v("delete(key)：通过键 key 从字典中移除对应的数据")]),v._v(" "),t("li",[v._v("clear()：将这个字典中的所有元素删除")])]),v._v(" "),t("p",[v._v("遍历：")]),v._v(" "),t("ul",[t("li",[v._v("Keys()：将字典中包含的所有键名以迭代器形式返回")]),v._v(" "),t("li",[v._v("values()：将字典中包含的所有数值以迭代器形式返回")]),v._v(" "),t("li",[v._v("entries()：返回所有成员的迭代器")]),v._v(" "),t("li",[v._v("forEach()：遍历字典的所有成员")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("ul",[t("li",[v._v("只有健值，没有健名，所以遍历的 key 和 value 一样")]),v._v(" "),t("li",[v._v("默认遍历器生成函数 entries()")])])]),v._v(" "),t("h3",{attrs:{id:"weakmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[v._v("#")]),v._v(" WeakMap")]),v._v(" "),t("p",[v._v("和 Map 的区别")]),v._v(" "),t("ul",[t("li",[v._v("键名只能是引用类型，并且是弱引用，可以被垃圾回收。")]),v._v(" "),t("li",[v._v("键值是正常引用")]),v._v(" "),t("li",[v._v("不可遍历")])]),v._v(" "),t("p",[v._v("方法：")]),v._v(" "),t("ul",[t("li",[v._v("has(key)：判断是否有 key 关联对象")]),v._v(" "),t("li",[v._v("get(key)：返回key关联对象（没有则则返回 undefined）")]),v._v(" "),t("li",[v._v("set(key)：设置一组key关联对象")]),v._v(" "),t("li",[v._v("delete(key)：移除 key 的关联对象")])])])}),[],!1,null,null,null);e.default=a.exports}}]);