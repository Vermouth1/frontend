(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{364:function(t,v,_){t.exports=_.p+"assets/img/HTTP2.86cdf01a.png"},365:function(t,v,_){t.exports=_.p+"assets/img/HTTP3&HTTP2.0bae470b.png"},366:function(t,v,_){t.exports=_.p+"assets/img/UDP.3edb673a.png"},367:function(t,v,_){t.exports=_.p+"assets/img/QUIC.05cc5720.png"},413:function(t,v,_){"use strict";_.r(v);var s=_(26),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),s("h2",{attrs:{id:"http-0-9"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-0-9"}},[t._v("#")]),t._v(" HTTP/0.9")]),t._v(" "),s("p",[t._v("由于需求简单，实现也简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("是只有一个请求行，并没有 HTTP 请求头和请求体")])]),t._v(" "),s("li",[s("strong",[t._v("服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。")])]),t._v(" "),s("li",[s("strong",[t._v("返回的文件内容是以 ASCII 字符流来传输的")])])]),t._v(" "),s("h2",{attrs:{id:"http-1-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[t._v("#")]),t._v(" HTTP/1.0")]),t._v(" "),s("ul",[s("li",[t._v("加入了"),s("strong",[t._v("请求头和响应头")]),t._v("，用来携带更多信息，并且在请求头中加入了"),s("strong",[t._v("用户代理")]),t._v("字段")]),t._v(" "),s("li",[t._v("加入"),s("strong",[t._v("状态码")])]),t._v(" "),s("li",[t._v("提供 "),s("strong",[t._v("Cache")]),t._v(" 机制")])]),t._v(" "),s("h2",{attrs:{id:"http-1-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),s("ul",[s("li",[t._v("改进持久连接，在"),s("strong",[t._v("一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。")])]),t._v(" "),s("li",[t._v("为了解决"),s("strong",[t._v("队头阻塞")]),t._v("，通过"),s("strong",[t._v("管线化")]),t._v("(将多个 HTTP 请求整批提交给服务器的技术)来解决，最后弃用")]),t._v(" "),s("li",[t._v("提供"),s("strong",[t._v("虚拟主机")]),t._v("的支持，请求头中增加了 Host 字段，用来表示当前的域名地址")]),t._v(" "),s("li",[t._v("对动态生成的内容提供了完美支持。引入 "),s("strong",[t._v("Chunk transfer")]),t._v(" 机制分块传输")]),t._v(" "),s("li",[t._v("引入了客户端 "),s("strong",[t._v("Cookie")]),t._v(" 机制和安全机制")])]),t._v(" "),s("p",[t._v("缺点问题：对带宽的利用率却并不理想")]),t._v(" "),s("ol",[s("li",[t._v("TCP 的慢启动。例如一些关键资源本身大小不大，但是由于慢启动也会耗费时间")]),t._v(" "),s("li",[t._v("宽带不足的时候，无法保证关键资源优先下载")]),t._v(" "),s("li",[t._v("队头阻塞问题，一个请求发出后，直到有了响应，才会继续发下一个请求")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("慢启动")]),t._v(" "),s("p",[t._v("TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。")])]),t._v(" "),s("h2",{attrs:{id:"http2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),s("p",[t._v("一个域名只使用一个 TCP 长连接")]),t._v(" "),s("p",[t._v("核心：多路复用，就是在一个 TCP 连接中存在多条流传输数据（流是多个帧组成的数据流，帧是最小的数据单位，有相同 id 的帧合并成流），即发送多条请求")]),t._v(" "),s("p",[t._v("优点：解决了 HTTP1 对头堵塞，但并没有解决 TCP 的队头堵塞（TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞）")]),t._v(" "),s("p",[s("img",{attrs:{src:_(364),alt:"HTTP2"}})]),t._v(" "),s("ol",[s("li",[t._v("浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。")]),t._v(" "),s("li",[t._v("这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。")]),t._v(" "),s("li",[t._v("服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息(数据流)。")]),t._v(" "),s("li",[t._v("然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。")]),t._v(" "),s("li",[t._v("同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。")]),t._v(" "),s("li",[t._v("浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。")])]),t._v(" "),s("p",[t._v("其他特性：")]),t._v(" "),s("ol",[s("li",[t._v("可以设置请求的优先级。可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。")]),t._v(" "),s("li",[t._v("服务器推送。直接将数据提前推送到浏览器。")]),t._v(" "),s("li",[t._v("头部压缩。对请求头和响应头进行了压缩")])]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("ol",[s("li",[t._v("由于多个请求只有一个 TCP 管道，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。")]),t._v(" "),s("li",[t._v("TCP 连接延时。三次握手过程，大概需要花费 3-4 个 RTT")])]),t._v(" "),s("h2",{attrs:{id:"http3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[t._v("#")]),t._v(" HTTP3")]),t._v(" "),s("p",[t._v("HTTP3 采用了 UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能的 QUIC 协议")]),t._v(" "),s("p",[s("img",{attrs:{src:_(365),alt:"HTTP3&HTTP2"}})]),t._v(" "),s("h3",{attrs:{id:"udp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[t._v("#")]),t._v(" UDP")]),t._v(" "),s("p",[t._v("UDP 是用户数据包协议（User Datagram Protocol），UDP 中一个最重要的信息是端口号，IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。"),s("strong",[t._v("UDP 并不提供重发机制，只是丢弃当前的包，但是传输速度却非常快")])]),t._v(" "),s("p",[s("img",{attrs:{src:_(366),alt:"UDP"}})]),t._v(" "),s("p",[t._v("HTTP3特性：")]),t._v(" "),s("ol",[s("li",[t._v("实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。")]),t._v(" "),s("li",[t._v("集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。")]),t._v(" "),s("li",[t._v("实现了 HTTP/2 中的多路复用功能，实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。"),s("img",{attrs:{src:_(367),alt:"QUIC"}})]),t._v(" "),s("li",[t._v("实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。")])]),t._v(" "),s("p",[t._v("目前存在的问题：")]),t._v(" "),s("ol",[s("li",[t._v("浏览器支持的问题")]),t._v(" "),s("li",[t._v("系统内核对 UDP 的优化远远没有达到 TCP 的优化程度")]),t._v(" "),s("li",[t._v("中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);